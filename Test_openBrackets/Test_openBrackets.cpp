#include "pch.h"
#include "CppUnitTest.h"
#include "../OpenBrackets/OpenBracketsHeader.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace TestopenBrackets
{
	TEST_CLASS(TestopenBrackets)
	{

	public:

		// Тестируется функция isEqualTree, которая реализована для тестов основных функций. Деревья равны.

		TEST_METHOD(testing_isEqualTree_treesAreEqual)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, 2, 3, "-"}, {1, 4, 5, "+"}, {1, NotExist, NotExist, "c"}, {2, NotExist, NotExist, "a"}, {2, NotExist, NotExist, "b"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = { {-1, 2, 3, "-"}, {1, 4, 5, "+"}, {1, NotExist, NotExist, "c"}, {2, NotExist, NotExist, "a"}, {2, NotExist, NotExist, "b"} };

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Тестируется функция isEqualTree, которая реализована для тестов основных функций. Деревья не равны.

		TEST_METHOD(testing_isEqualTree_treesAreNotEqual)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, 2, 3, "-"}, {1, 4, 5, "+"}, {1, NotExist, NotExist, "c"}, {2, NotExist, NotExist, "a"}, {2, NotExist, NotExist, "b"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = { {-1, 2, 3, "-"}, {1, 4, 5, "+"}, {1, NotExist, NotExist, "c"}, {2, NotExist, NotExist, "a"}};

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsFalse(isEqualTree);
		}

		// Преобразование запрещено так как при перестановке изменяется выражение
		TEST_METHOD(transformationIsForbidden) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, -1, -1, "\0"},
										{-1, 2, 3, "-"},
										{1, -1, -1, "a"},
										{1, -1, -1, "b"}};
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "-"},
											{1, -1, -1, "a"},
											{1, -1, -1, "b"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Скобки задают приоритет сложению над умножением
		TEST_METHOD(priorityToAdditionOverMultiplication) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 5, "*"},
										{1, 3, 4, "+"},
										{2, -1, -1, "a"},
										{2, -1, -1, "b"},
										{1, -1, -1, "c"}};
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{1, 3, 4, "\0"},
											{31, -1, -1, "a"},
											{32, -1, -1, "b"},
											{31, -1, -1, "c"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "c"},
											{1, 3, 5, "*"},
											{1, 4, 30, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Скобки задают приоритет сложению над побитовым умножением
		TEST_METHOD(priorityToAdditionOverByteMultiplication) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, -1, -1, "\0"},
										{-1, 2, 5, "&"},
										{1, 3, 4, "+"},
										{2, -1, -1, "a"},
										{2, -1, -1, "b"},
										{1, -1, -1, "c"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = { {-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{1, 3, 4, "\0"},
											{31, -1, -1, "a"},
											{32, -1, -1, "b"},
											{31, -1, -1, "c"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "c"},
											{1, 3, 5, "&"},
											{1, 4, 30, "&"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Скобки задают приоритет вычитанию над умножением
		TEST_METHOD(priorityToSubOverMultiplication) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, -1, -1, "\0"},
										{-1, 2, 5, "*"},
										{1, 3, 4, "-"},
										{2, -1, -1, "a"},
										{2, -1, -1, "b"},
										{1, -1, -1, "c"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = { {-1, -1, -1, "\0"},
											{-1, 31, 32, "-"},
											{1, 3, 4, "\0"},
											{31, -1, -1, "a"},
											{32, -1, -1, "b"},
											{31, -1, -1, "c"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "c"},
											{1, 3, 5, "*"},
											{1, 4, 30, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Скобки задают приоритет вычитанию над побитовым умножением
		TEST_METHOD(priorityToSubOverByteMultiplication) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, -1, -1, "\0"},
										{-1, 2, 5, "&"},
										{1, 3, 4, "-"},
										{2, -1, -1, "a"},
										{2, -1, -1, "b"},
										{1, -1, -1, "c"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = { {-1, -1, -1, "\0"},
											{-1, 31, 32, "-"},
											{1, 3, 4, "\0"},
											{31, -1, -1, "a"},
											{32, -1, -1, "b"},
											{31, -1, -1, "c"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "c"},
											{1, 3, 5, "&"},
											{1, 4, 30, "&"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Скобки задают приоритет любым операциям над любыми операциями в других скобках
		TEST_METHOD(priorityToOperationsOverOtherBracketsOperations) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "+"},
										{1, 6, 7, "+"},
										{2, -1, -1, "a"},
										{2, -1, -1, "b"},
										{3, -1, -1, "c"},
										{3, 8, 9, "+"},
										{7, -1, -1, "f"},
										{7, 10, 11, "*"},
										{9, -1, -1, "d"},
										{9, -1, -1, "e"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, 38, 39, "+"},
											{1, 40, 41, "+"},
											{38, -1, -1, "a"},
											{40, -1, -1, "b"},
											{38, -1, -1, "c"},
											{39, 34, 35, "\0"},
											{46, -1, -1, "f"},
											{47, 36, 37, "*"},
											{9, -1, -1, "d"},
											{9, -1, -1, "e"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{43, -1, -1, "a"},
											{40, -1, -1, "c"},
											{46, -1, -1, "b"},
											{41, 8, 9, "\0"},
											{43, -1, -1, "f"},
											{44, 10, 11, "*"},
											{9, -1, -1, "d"},
											{9, -1, -1, "e"},
											{2, 4, 6, "*"},
											{2, 43, 44, "+"},
											{3, 5, 31, "*"},
											{3, 46, 47, "+"},
											{44, -1, -1, "a"},
											{39, 34, 30, "*"},
											{39, 35, 42, "*"},
											{47, -1, -1, "b"},
											{41, 8, 32, "*"},
											{41, 9, 45, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Преобразование выражения с низкоприоритетными операциями не требуется, но перестановка операндов не приведет к ошибке
		TEST_METHOD(noTransformationNeededLowPriority) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "+"},
										{1, -1, -1, "a"},
										{1, -1, -1, "b"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, -1, -1, "a"},
											{1, -1, -1, "b"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Преобразование выражения с высокоприоритетными операциями не требуется, но перестановка операндов не приведет к ошибке
		TEST_METHOD(noTransformationNeededHighPriority) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, -1, -1, "a"},
										{1, -1, -1, "b"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "*"},
											{1, -1, -1, "a"},
											{1, -1, -1, "b"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Умножение на -1 суммы
		TEST_METHOD(multiplicationOfSumAndNegativeUnit) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, -1, -1, "-1"},
										{1, 4, 5, "+"},
										{3, -1, -1, "a"},
										{3, -1, -1, "b"}};
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{31, -1, -1, "-1"},
											{1, 4, 5, "\0"},
											{31, -1, -1, "a"},
											{32, -1, -1, "b"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "-1"},
											{1, 4, 2, "*"},
											{1, 5, 30, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Умножение на -1 разности
		TEST_METHOD(multiplicationOfSubAndNegativeUnit) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, -1, -1, "-1"},
										{1, 4, 5, "-"},
										{3, -1, -1, "a"},
										{3, -1, -1, "b"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = { {-1, -1, -1, "\0"},
											{-1, 31, 32, "-"},
											{31, -1, -1, "-1"},
											{1, 4, 5, "\0"},
											{31, -1, -1, "a"},
											{32, -1, -1, "b"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "-1"},
											{1, 4, 2, "*"},
											{1, 5, 30, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Умножение на -1 составного выражения 
		TEST_METHOD(multiplicationOfCompositeExpressionAndNegativeUnit) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, -1, -1, "-1"},
										{1, 4, 7, "+"},
										{3, 5, 6, "&"},
										{4, -1, -1, "a"},
										{4, -1, -1, "b"},
										{3, 8, 9, "-"},
										{7, -1, -1, "d"},
										{7, -1, -1, "k"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{31, -1, -1, "-1"},
											{1, 4, 7, "\0"},
											{31, 5, 6, "&"},
											{4, -1, -1, "a"},
											{4, -1, -1, "b"},
											{32, 8, 9, "\0"},
											{34, -1, -1, "d"},
											{35, -1, -1, "k"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{34, -1, -1, "-1"},
											{1, 4, 2, "*"},
											{1, 34, 35, "-"},
											{35, -1, -1, "-1"},
											{32, 8, 30, "*"},
											{32, 9, 33, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Распределительный закон для нескольких скобок
		TEST_METHOD(multiplicationOfSomeBrackets) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "+"},
										{1, 6, 7, "+"},
										{2, -1, -1, "a"},
										{2, -1, -1, "b"},
										{3, -1, -1, "c"},
										{3, -1, -1, "d"}};
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, 34, 35, "+"},
											{1, 36, 37, "+"},
											{34, -1, -1, "a"},
											{36, -1, -1, "b"},
											{34, -1, -1, "c"},
											{35, -1, -1, "d"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{35, -1, -1, "a"},
											{36, -1, -1, "c"},
											{37, -1, -1, "b"},
											{37, -1, -1, "d"},
											{2, 4, 6, "*"},
											{2, 30, 7, "*"},
											{3, 5, 31, "*"},
											{3, 32, 33, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Умножение с операндами-числами
		TEST_METHOD(multiplicationOfNumbersOperands) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 5, "*"},
										{1, 3, 4, "+"},
										{2, -1, -1, "1"},
										{2, -1, -1, "2"},
										{1, -1, -1, "3"}};
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{1, 3, 4, "\0"},
											{31, -1, -1, "1"},
											{32, -1, -1, "2"},
											{31, -1, -1, "3"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "3"},
											{1, 3, 5, "*"},
											{1, 4, 30, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Умножение со смешанным типом операндов
		TEST_METHOD(multiplicationOfMixOperands) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 5, "*"},
										{1, 3, 4, "+"},
										{2, -1, -1, "1"},
										{2, -1, -1, "a"},
										{1, -1, -1, "2ef"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{1, 3, 4, "\0"},
											{31, -1, -1, "1"},
											{32, -1, -1, "a"},
											{31, -1, -1, "2ef"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "2ef"},
											{1, 3, 5, "*"},
											{1, 4, 30, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// При раскрытии выражения рекурсивный обход дерева должны происходить не один раз  (a+b)*(1-(-2 - (c+d))) = a*1-a*(-2)+c*a+d*a+b*1-b*(-2)+c*b+d*b
		TEST_METHOD(whileTransformationRecursionNotOnlyOnce) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = { {-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "+"},
										{1, 6, 7, "-"},
										{2, -1, -1, "a"},
										{2, -1, -1, "b"},
										{3, -1, -1, "1"},
										{3, 8, 9, "-"},
										{7, -1, -1, "-2"},
										{7, 10, 11, "+"},
										{9, -1, -1, "c"},
										{9, -1, -1, "d"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = { {-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, 38, 39, "-"},
											{1, 40, 41, "-"},
											{46, -1, -1, "a"},
											{52, -1, -1, "b"},
											{46, -1, -1, "1"},
											{49, 33, 34, "\0"},
											{39, -1, -1, "-2"},
											{38, 32, 35, "\0"},
											{47, -1, -1, "c"},
											{50, -1, -1, "d"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{39, -1, -1, "a"},
											{40, 7, 11, "\0"},
											{43, 6, 10, "\0"},
											{52, -1, -1, "1"},
											{53, -1, -1, "c"},
											{44, -1, -1, "d"},
											{41, -1, -1, "b"},
											{41, -1, -1, "-2"},
											{2, 43, 44, "+"},
											{2, 30, 8, "*"},
											{3, 49, 50, "+"},
											{3, 36, 37, "*"},
											{44, -1, -1, "a"},
											{38, 46, 47, "+"},
											{38, 35, 42, "*"},
											{47, -1, -1, "a"},
											{43, 6, 4, "*"},
											{43, 10, 45, "*"},
											{50, -1, -1, "b"},
											{40, 52, 53, "+"},
											{40, 11, 48, "*"},
											{53, -1, -1, "b"},
											{49, 33, 5, "*"},
											{49, 34, 51, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// У рекурсии не одно направление a-1*(0+1*(-1*((-a)-b)))
		TEST_METHOD(notOnlyOneRecursionDirection) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "-"},
										{1, -1, -1, "a"},
										{1, 4, 5, "*"},
										{3, -1, -1, "1"},
										{3, 6, 7, "+"},
										{5, -1, -1, "0"},
										{5, 8, 9, "*"},
										{7, -1, -1, "1"},
										{7, 10, 11, "*"},
										{9, -1, -1, "-1"},
										{9, 12, 13, "-"},
										{11, -1, -1, "-a"},
										{11, -1, -1, "b"}};
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 3, 37, "-"},
											{38, -1, -1, "a"},
											{1, 38, 40, "-"},
											{37, -1, -1, "1"},
											{3, 6, 7, "\0"},
											{37, -1, -1, "0"},
											{38, 34, 35, "\0"},
											{34, -1, -1, "1"},
											{7, 31, 32, "\0"},
											{31, -1, -1, "-1"},
											{9, 12, 13, "\0"},
											{31, -1, -1, "-a"},
											{32, -1, -1, "b"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "-1"},
											{34, 12, 10, "*"},
											{35, 13, 30, "*"},
											{35, -1, -1, "1"},
											{40, 31, 8, "*"},
											{41, 32, 33, "*"},
											{40, -1, -1, "1"},
											{1, 6, 4, "*"},
											{3, 2, 41, "+"},
											{41, -1, -1, "1"},
											{3, 34, 36, "*"},
											{38, 35, 39, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Комплексный тест из внешней спецификации, у вершин исходного дерева индексы не по порядку
		TEST_METHOD(сomplexTest) 
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "+"},
										{1, 7, 6, "-"},
										{1, 5, 4, "*"},
										{3, 11, 29, "+"},
										{3, 9, 10, "+"},
										{2, -1, -1, "b"},
										{2, -1, -1, "8"},
										{-1, -1, -1, "\0"},
										{5, -1, -1, "2"},
										{5, -1, -1, "3"},
										{4, -1, -1, "val"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{4, -1, -1, "var123"} };
			initializeFullTree(inputTree);

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, 7, 6, "-"},
											{1, 5, 4, "+"},
											{3, 36, 37, "+"},
											{3, 34, 35, "+"},
											{2, -1, -1, "b"},
											{2, -1, -1, "8"},
											{-1, -1, -1, "\0"},
											{34, -1, -1, "2"},
											{36, -1, -1, "3"},
											{34, -1, -1, "val"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{35, -1, -1, "var123"},
											{35, -1, -1, "2"},
											{36, -1, -1, "val"},
											{37, -1, -1, "3"},
											{37, -1, -1, "var123"},
											{5, 9, 11, "*"},
											{5, 30, 29, "*"},
											{4, 10, 31, "*"},
											{4, 32, 33, "*"} };

			openBrackets(inputTree, inputRoot);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}
	};
}
