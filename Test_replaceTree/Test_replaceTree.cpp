#include "pch.h"
#include "CppUnitTest.h"
#include "../OpenBrackets/OpenBracketsHeader.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace TestreplaceTree
{
	TEST_CLASS(TestreplaceTree)
	{
	public:
		
		// Перестройка дерева не требуется так как операций ниже нет
		TEST_METHOD(rebuldingNotNedeed)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "+"},
										{1, -1, -1, "a"},
										{1, -1, -1, "3"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, -1, -1, "a"},
											{1, -1, -1, "3"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"}}; 

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева не требуется так как ниже идентичная операция
		TEST_METHOD(equalOperationUnderNode)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "*"},
										{1, -1, -1, "c"},
										{2, -1, -1, "a"},
										{2, -1, -1, "12"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };
			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "*"},
											{1, 4, 5, "*"},
											{1, -1, -1, "c"},
											{2, -1, -1, "a"},
											{2, -1, -1, "12"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева не требуется так как ниже операции с тем же приоритетом, но перестановка разрешена
		TEST_METHOD(noHigherPriorityUnderNode)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "+"},
										{1, 4, 5, "+"},
										{1, -1, -1, "c"},
										{2, -1, -1, "a"},
										{2, -1, -1, "12"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{1, 4, 5, "\0"},
											{31, -1, -1, "c"},
											{31, -1, -1, "a"},
											{32, -1, -1, "12"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "c"},
											{1, 4, 3, "+"},
											{1, 5, 30, "+"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, операция + слева
		TEST_METHOD(plusOperationFromLeft)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "+"},
										{1, -1, -1, "xxx"},
										{2, -1, -1, "xx1"},
										{2, -1, -1, "xx2"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{1, 4, 5, "\0"},
											{31, -1, -1, "xxx"},
											{31, -1, -1, "xx1"},
											{32, -1, -1, "xx2"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "xxx"},
											{1, 4, 3, "*"},
											{1, 5, 30, "*"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, операция - слева
		TEST_METHOD(minusOperationFromLeft)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "-"},
										{1, -1, -1, "xxx"},
										{2, -1, -1, "xx1"},
										{2, -1, -1, "xx2"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "-"},
											{1, 4, 5, "\0"},
											{31, -1, -1, "xxx"},
											{31, -1, -1, "xx1"},
											{32, -1, -1, "xx2"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "xxx"},
											{1, 4, 3, "*"},
											{1, 5, 30, "*"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, операция + справа
		TEST_METHOD(plusOperationFromRight)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	 {-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, -1, -1, "xxx"},
										{1, 4, 5, "+"},
										{3, -1, -1, "xx1"},
										{3, -1, -1, "xx2"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "+"},
											{31, -1, -1, "xxx"},
											{1, 4, 5, "\0"},
											{31, -1, -1, "xx1"},
											{32, -1, -1, "xx2"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "xxx"},
											{1, 4, 2, "*"},
											{1, 5, 30, "*"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, операция - справа
		TEST_METHOD(minusOperationFromRight)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, -1, -1, "xxx"},
										{1, 4, 5, "-"},
										{3, -1, -1, "xx1"},
										{3, -1, -1, "xx2"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 31, 32, "-"},
											{31, -1, -1, "xxx"},
											{1, 4, 5, "\0"},
											{31, -1, -1, "xx1"},
											{32, -1, -1, "xx2"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{32, -1, -1, "xxx"},
											{1, 4, 2, "*"},
											{1, 5, 30, "*"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, операция + и слева и справа
		TEST_METHOD(plusOperationFromLeftAndRight)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "+"},
										{1, 6, 7, "+"},
										{2, -1, -1, "xx1"},
										{2, -1, -1, "xx2"},
										{3, -1, -1, "yy1"},
										{3, -1, -1, "yy2"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, 34, 35, "+"},
											{1, 36, 37, "+"},
											{34, -1, -1, "xx1"},
											{36, -1, -1, "xx2"},
											{34, -1, -1, "yy1"},
											{35, -1, -1, "yy2"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{35, -1, -1, "xx1"},
											{36, -1, -1, "yy1"},
											{37, -1, -1, "xx2"},
											{37, -1, -1, "yy2"},
											{2, 4, 6, "*"},
											{2, 30, 7, "*"},
											{3, 5, 31, "*"},
											{3, 32, 33, "*"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, операция - и слева и справа
		TEST_METHOD(minusOperationFromLeftAndRight)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "-"},
										{1, 6, 7, "-"},
										{2, -1, -1, "xx1"},
										{2, -1, -1, "xx2"},
										{3, -1, -1, "yy1"},
										{3, -1, -1, "yy2"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, 34, 35, "-"},
											{1, 36, 37, "-"},
											{34, -1, -1, "xx1"},
											{36, -1, -1, "xx2"},
											{34, -1, -1, "yy1"},
											{35, -1, -1, "yy2"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{35, -1, -1, "xx1"},
											{36, -1, -1, "yy2"},
											{37, -1, -1, "xx2"},
											{37, -1, -1, "yy1"},
											{2, 4, 6, "*"},
											{2, 30, 7, "*"},
											{3, 5, 31, "*"},
											{3, 32, 33, "*"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, низкоприоритетные операции и слева и справа
		TEST_METHOD(lowPriorityOperationFromLeftAndRight)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "+"},
										{1, 6, 7, "-"},
										{2, -1, -1, "xx1"},
										{2, -1, -1, "xx2"},
										{3, -1, -1, "yy1"},
										{3, -1, -1, "yy2"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 3, "+"},
											{1, 34, 35, "-"},
											{1, 36, 37, "-"},
											{34, -1, -1, "xx1"},
											{36, -1, -1, "xx2"},
											{34, -1, -1, "yy1"},
											{35, -1, -1, "yy2"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{35, -1, -1, "xx1"},
											{36, -1, -1, "yy1"},
											{37, -1, -1, "xx2"},
											{37, -1, -1, "yy2"},
											{2, 4, 6, "*"},
											{2, 30, 7, "*"},
											{3, 5, 31, "*"},
											{3, 32, 33, "*"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, рекурсия несколько раз
		TEST_METHOD(recursionNotOnlyOnce)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 5, "*"},
										{1, 3, 4, "+"},
										{2, -1, -1, "a"},
										{2, -1, -1, "b"},
										{1, 6, 9, "+"},
										{5, 7, 8, "+"},
										{6, -1, -1, "c"},
										{6, -1, -1, "d"},
										{5, 10, 11, "+"},
										{9, -1, -1, "c"},
										{9, -1, -1, "d"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 2, 5, "+"},
											{1, 38, 39, "+"},
											{38, -1, -1, "a"},
											{40, -1, -1, "b"},
											{1, 40, 41, "+"},
											{38, 32, 33, "+"},
											{6, -1, -1, "c"},
											{6, -1, -1, "d"},
											{39, 36, 37, "+"},
											{9, -1, -1, "c"},
											{9, -1, -1, "d"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{39, -1, -1, "a"},
											{40, 7, 8, "+"},
											{6, -1, -1, "c"},
											{6, -1, -1, "d"},
											{41, -1, -1, "b"},
											{41, 10, 11, "+"},
											{9, -1, -1, "c"},
											{9, -1, -1, "d"},
											{2, 3, 6, "*"},
											{2, 30, 9, "*"},
											{5, 4, 31, "*"},
											{5, 34, 35, "*"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, операции со смешанным приоритетом и слева и справа
		TEST_METHOD(differentPriorityOperationFromLeftAndRight)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "*"},
										{1, 4, 5, "+"},
										{1, 6, 7, "&"},
										{2, -1, -1, "xx1"},
										{2, -1, -1, "xx2"},
										{3, -1, -1, "yy1"},
										{3, -1, -1, "yy2"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 33, 34, "+"},
											{1, 4, 5, "\0"},
											{33, 31, 32, "&"},
											{33, -1, -1, "xx1"},
											{34, -1, -1, "xx2"},
											{3, -1, -1, "yy1"},
											{3, -1, -1, "yy2"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{34, 6, 7, "&"},
											{3, -1, -1, "yy1"},
											{3, -1, -1, "yy2"},
											{1, 4, 3, "*"},
											{1, 5, 30, "*"} };
			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Перестройка дерева требуется, есть умножение на -1 перед скобкой
		TEST_METHOD(negativeUnitMultiplication)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 3, "-"},
										{1, -1, -1, "c"},
										{1, 4, 5, "*"},
										{3, -1, -1, "1"},
										{3, 6, 7, "+"},
										{5, -1, -1, "a"},
										{5, -1, -1, "b"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 3, 4, "-"},
											{3, -1, -1, "c"},
											{1, 2, 5, "*"},
											{1, -1, -1, "1"},
											{3, 6, 7, "+"},
											{5, -1, -1, "a"},
											{5, -1, -1, "b"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}

		// Комплексный тест
		TEST_METHOD(complexTest)
		{
			// Входное дерево
			int inputRoot = 1;
			vector<Node> inputTree = {	{-1, -1, -1, "\0"},
										{-1, 2, 5, "&"},
										{1, 3, 4, "-"},
										{2, -1, -1, "k"},
										{2, -1, -1, "r3"},
										{1, 6, 9, "*"},
										{5, 7, 8, "*"},
										{6, 10, 11, "+"},
										{6, -1, -1, "5"},
										{5, -1, -1, "a"},
										{7, -1, -1, "temp"},
										{7, -1, -1, "c9oNn"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"},
										{-1, -1, -1, "\0"} };

			// Ожидаемое дерево
			int expectedRoot = 1;
			vector<Node> expectedTree = {	{-1, -1, -1, "\0"},
											{-1, 37, 38, "-"},
											{1, 3, 4, "\0"},
											{37, -1, -1, "k"},
											{38, -1, -1, "r3"},
											{37, 31, 36, "*"},
											{5, 32, 35, "*"},
											{6, 33, 34, "+"},
											{6, -1, -1, "5"},
											{5, -1, -1, "a"},
											{7, -1, -1, "temp"},
											{7, -1, -1, "c9oNn"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{-1, -1, -1, "\0"},
											{38, 6, 9, "*"},
											{5, 7, 8, "*"},
											{6, 10, 11, "+"},
											{7, -1, -1, "temp"},
											{7, -1, -1, "c9oNn"},
											{6, -1, -1, "5"},
											{5, -1, -1, "a"},
											{1, 3, 5, "&"},
											{1, 4, 30, "&"} };

			replaceTree(inputTree, inputRoot, inputTree[inputRoot].value);

			bool isEqualTree = isEqualTrees(expectedTree, expectedRoot, inputTree, inputRoot);

			Assert::IsTrue(isEqualTree);
		}
	};
}
